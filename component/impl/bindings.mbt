// Generated by moon-component
// DO NOT EDIT - this file is regenerated

///|
pub(all) struct MatchResult {
  diff_count : UInt
  output : Array[Byte]?
} derive(Show, Eq)

///| Re-export cabi_realloc for wasm linking
pub fn cabi_realloc(
  old_ptr : Int,
  old_size : Int,
  align : Int,
  new_size : Int,
) -> Int {
  @cabi.cabi_realloc(old_ptr, old_size, align, new_size)
}

pub fn wasmExportMatchRatio(img1_data_ptr : Int, img1_data_len : Int, img2_data_ptr : Int, img2_data_len : Int, width : Int, height : Int, threshold : Double, include_aa : Int, alpha : Double, diff_mask : Int) -> Double {
  let img1_data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=img1_data_len)
    for i = 0; i < img1_data_len; i = i + 1 {
      let elem_ptr = img1_data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  let img2_data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=img2_data_len)
    for i = 0; i < img2_data_len; i = i + 1 {
      let elem_ptr = img2_data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  match_ratio(img1_data, img2_data, width.reinterpret_as_uint(), height.reinterpret_as_uint(), threshold, include_aa, alpha, diff_mask)
}

pub fn wasmExportPixelmatch(img1_data_ptr : Int, img1_data_len : Int, img2_data_ptr : Int, img2_data_len : Int, width : Int, height : Int, include_output : Int, threshold : Double, include_aa : Int, alpha : Double, diff_mask : Int) -> Int {
  let img1_data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=img1_data_len)
    for i = 0; i < img1_data_len; i = i + 1 {
      let elem_ptr = img1_data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  let img2_data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=img2_data_len)
    for i = 0; i < img2_data_len; i = i + 1 {
      let elem_ptr = img2_data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  let result = pixelmatch(img1_data, img2_data, width.reinterpret_as_uint(), height.reinterpret_as_uint(), include_output, threshold, include_aa, alpha, diff_mask)
  let retptr = @cabi.cabi_realloc(0, 0, 4, 16)
  // Lower record to linear memory
      @cabi.cabi_write_i32(retptr + 0, result.diff_count.reinterpret_as_int())
      match result.output {
        Some(payload) => {
          @cabi.cabi_write_u8(retptr + 4, (1).to_byte())
          let len = payload.length()
          let elem_size = 1
          let ptr = @cabi.cabi_realloc(0, 0, 1, len * elem_size)
          for i, elem in payload {
            let elem_ptr = ptr + i * elem_size
    @cabi.cabi_write_u8(elem_ptr, elem)
          }
          @cabi.cabi_write_i32(retptr + 4 + 4, ptr)
          @cabi.cabi_write_i32(retptr + 4 + 4 + 4, len)
        }
        None => @cabi.cabi_write_u8(retptr + 4, (0).to_byte())
      }
  retptr
}

pub fn wasmExportPixelmatchSimple(img1_data_ptr : Int, img1_data_len : Int, img2_data_ptr : Int, img2_data_len : Int, width : Int, height : Int, threshold : Double) -> Int {
  let img1_data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=img1_data_len)
    for i = 0; i < img1_data_len; i = i + 1 {
      let elem_ptr = img1_data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  let img2_data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=img2_data_len)
    for i = 0; i < img2_data_len; i = i + 1 {
      let elem_ptr = img2_data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  pixelmatch_simple(img1_data, img2_data, width.reinterpret_as_uint(), height.reinterpret_as_uint(), threshold).reinterpret_as_int()
}

///|
fn main {
  ()
}
